// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.29.3
// source: models.proto

package evm

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// A confirmed block on an EVM-compatible blockchain containing transactions and state changes
type BlockHeader struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The block height - sequential position of this block in the blockchain starting from genesis (0). This is the primary identifier for blocks and is used for chain synchronization, determining finality depth, and calculating confirmations. Every valid block must have a unique number that is exactly one greater than its parent
	Number uint64 `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
	// Unix timestamp (seconds since epoch) when this block was mined/produced. Set by the block producer and used for calculating block time intervals, time-based logic in smart contracts (block.timestamp), and difficulty adjustments. Must be greater than parent's timestamp. Manipulatable by miners/validators within protocol limits (typically Â±15 seconds)
	Timestamp uint64 `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Maximum total gas that can be consumed by all transactions in this block. Set by miners/validators based on network capacity and protocol rules. Prevents blocks from becoming too large/slow to process. Dynamically adjusted on some chains (e.g., Ethereum targets 15M gas with EIP-1559 allowing up to 30M)
	GasLimit uint64 `protobuf:"varint,3,opt,name=gasLimit,proto3" json:"gasLimit,omitempty"`
	// Sum of gas actually consumed by all transactions in this block. Always less than or equal to gasLimit. Used to calculate block utilization, network congestion, and in EIP-1559 chains to adjust the base fee. Critical for gas analytics and optimization
	GasUsed uint64 `protobuf:"varint,4,opt,name=gasUsed,proto3" json:"gasUsed,omitempty"`
	// Total size of the block in bytes including header and all transactions. Used to enforce block size limits, calculate network bandwidth requirements, and storage costs. Ethereum soft limit ~1.875MB (gas limit / 16). Different from gas limit as it measures actual data size
	Size uint64 `protobuf:"varint,5,opt,name=size,proto3" json:"size,omitempty"`
	// The Keccak-256 hash of the block header (parentHash, unclesHash, miner, stateRoot, transactionsRoot, receiptsRoot, logsBloom, difficulty, number, gasLimit, gasUsed, timestamp, extraData, mixHash, nonce). This serves as a unique identifier and cryptographic fingerprint that proves the block's integrity. Used in the PoW/PoS consensus to link blocks and detect chain reorganizations
	Hash []byte `protobuf:"bytes,6,opt,name=hash,proto3" json:"hash,omitempty"`
	// The Keccak-256 hash of the parent block's header. This creates the blockchain's linked structure where each block references its predecessor. The genesis block has a parent hash of 0x0. Used by nodes to validate chain continuity and detect forks or reorganizations
	ParentHash []byte `protobuf:"bytes,7,opt,name=parentHash,proto3" json:"parentHash,omitempty"`
	// Root hash of the global state trie (Patricia Merkle Tree) after executing all transactions in this block. Represents the entire Ethereum state (all accounts, balances, storage, code). Enables light clients to verify state without storing it. Critical for state proofs and cross-chain bridges
	StateRoot []byte `protobuf:"bytes,8,opt,name=stateRoot,proto3" json:"stateRoot,omitempty"`
	// Root hash of the transactions trie containing all transactions included in this block. Enables Merkle proofs of transaction inclusion. Transactions are indexed by their position in the block. Essential for light clients and SPV (Simplified Payment Verification)
	TransactionsRoot []byte `protobuf:"bytes,9,opt,name=transactionsRoot,proto3" json:"transactionsRoot,omitempty"`
	// Root hash of the receipts trie containing transaction receipts (status, logs, gas used) for all transactions in this block. Enables Merkle proofs of transaction execution results and emitted events. Critical for proving transaction success/failure and log inclusion
	ReceiptsRoot []byte `protobuf:"bytes,10,opt,name=receiptsRoot,proto3" json:"receiptsRoot,omitempty"`
	// Keccak-256 hash of the uncles (ommer blocks) list. Uncle blocks are valid blocks mined at the same height but not included in the main chain. Ethereum rewards uncle blocks to reduce mining centralization. Always 0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347 (empty uncle list hash) post-merge
	Sha3Uncles []byte `protobuf:"bytes,11,opt,name=sha3Uncles,proto3" json:"sha3Uncles,omitempty"`
	// The 20-byte Ethereum address that received the block reward and transaction fees. In PoW chains, this is the miner who found the valid nonce. In PoS chains, this is the validator who proposed the block. In L2s, this is typically the sequencer address. Also called 'author' or 'coinbase' in some contexts
	Miner []byte `protobuf:"bytes,12,opt,name=miner,proto3" json:"miner,omitempty"`
	// 2048-bit (256 bytes) bloom filter of all log topics and addresses from all transactions in the block. Enables efficient filtering of logs without processing all transactions. Each log adds its address and topics to the bloom filter. Used by eth_getLogs to quickly skip irrelevant blocks
	LogsBloom []byte `protobuf:"bytes,13,opt,name=logsBloom,proto3" json:"logsBloom,omitempty"`
	// Arbitrary data included by the block producer. Limited to 32 bytes in Ethereum mainnet. Often contains miner/pool identification, voting data, or protocol-specific information. In Clique PoA networks contains validator signatures. L2s may use for additional protocol data
	ExtraData []byte `protobuf:"bytes,14,opt,name=extraData,proto3" json:"extraData,omitempty"`
	// [DEPRECATED: Deprecated for consensus after Ethereum's transition to Proof-of-Stake, always zero in PoS blocks] PoW mining nonce - 64-bit value miners increment to find a valid block hash below the difficulty target. Combined with mixHash to prove work. Always 0x0000000000000000 in PoS blocks. Some PoA networks use for validator voting
	Nonce *uint64 `protobuf:"varint,15,opt,name=nonce,proto3,oneof" json:"nonce,omitempty"`
	// Total blob gas consumed by blob-carrying transactions (EIP-4844) in this block. Each blob consumes 131072 gas units. Used to calculate blob fees separately from regular gas. Introduced in Dencun upgrade for proto-danksharding. Maximum 786432 (6 blobs) per block
	BlobGasUsed *uint64 `protobuf:"varint,16,opt,name=blobGasUsed,proto3,oneof" json:"blobGasUsed,omitempty"`
	// Running total of blob gas consumed above the target (393216 gas, 3 blobs) from previous block. Used in EIP-4844 to calculate blob base fee similar to EIP-1559. Increases when blob usage is high, decreases when low. Enables dynamic blob pricing independent of regular gas
	ExcessBlobGas *uint64 `protobuf:"varint,17,opt,name=excessBlobGas,proto3,oneof" json:"excessBlobGas,omitempty"`
	// The L1 (Ethereum mainnet) block number that this L2 block is anchored to. Used by L2 sequencers to establish data availability and finality. Critical for L2->L1 messaging, challenge periods, and state root submissions. Timing varies by L2 design (optimistic vs zk rollups)
	L1BlockNumber *uint64 `protobuf:"varint,18,opt,name=l1BlockNumber,proto3,oneof" json:"l1BlockNumber,omitempty"`
	// Beacon chain epoch number (32 slots, ~6.4 minutes). Groups slots for validator duties, finality checkpoints, and validator set changes. Ethereum-specific post-merge concept. Epoch 0 started at beacon chain genesis (Dec 1, 2020). Used for staking analytics
	Epoch *uint64 `protobuf:"varint,19,opt,name=epoch,proto3,oneof" json:"epoch,omitempty"`
	// Beacon chain slot number (12 seconds). The primary time unit in PoS Ethereum. Each slot has one assigned validator to propose a block (though slots can be missed). Started at 0 with beacon chain genesis. Maps to execution layer blocks post-merge
	Slot *uint64 `protobuf:"varint,20,opt,name=slot,proto3,oneof" json:"slot,omitempty"`
	// Beacon chain validator index that proposed this block. Identifies which of the hundreds of thousands of validators created this block. Used for validator performance tracking, MEV analysis, and slashing detection. Only available from beacon chain data
	ProposerIndex *uint64 `protobuf:"varint,21,opt,name=proposerIndex,proto3,oneof" json:"proposerIndex,omitempty"`
	// Arbitrum-specific field tracking the number of L2-to-L1 messages sent in this block. Used for cross-chain message tracking and calculating merkle proofs for the outbox. Critical for Arbitrum's optimistic rollup message passing system
	SendCount *uint64 `protobuf:"varint,22,opt,name=sendCount,proto3,oneof" json:"sendCount,omitempty"`
	// Number of transactions included in this block. Derived from transactions array length but stored separately by some indexers for query efficiency. Includes all transaction types (legacy, EIP-1559, blob transactions). Zero for empty blocks
	TransactionCount *uint32 `protobuf:"varint,23,opt,name=transactionCount,proto3,oneof" json:"transactionCount,omitempty"`
	// [DEPRECATED: Original PoW purpose deprecated, now repurposed for beacon chain RANDAO in PoS] PoW mining mix hash used with nonce to prove work was done. Part of Ethash algorithm preventing ASIC optimization. Post-merge contains the RANDAO value from the beacon chain providing randomness for PoS consensus. Sometimes called 'prevRandao' in PoS context
	MixHash []byte `protobuf:"bytes,24,opt,name=mixHash,proto3,oneof" json:"mixHash,omitempty"`
	// Hash of the parent beacon chain block root. Introduced in EIP-4788 (Dencun) to enable trustless access to beacon chain state from the EVM. Stored in a system contract at 0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02. Enables staking pools and bridges to verify consensus layer data on-chain
	ParentBeaconBlockRoot []byte `protobuf:"bytes,25,opt,name=parentBeaconBlockRoot,proto3,oneof" json:"parentBeaconBlockRoot,omitempty"`
	// Root hash of the withdrawals trie containing validator withdrawals from the beacon chain. Introduced with Shanghai upgrade enabling staked ETH withdrawals. Empty/null for pre-Shanghai blocks and non-Ethereum chains. Each withdrawal moves ETH from consensus to execution layer
	WithdrawalsRoot []byte `protobuf:"bytes,26,opt,name=withdrawalsRoot,proto3,oneof" json:"withdrawalsRoot,omitempty"`
	// Arbitrum-specific merkle root of all L2-to-L1 messages sent up to and including this block. Enables efficient proof generation for message inclusion. Updated incrementally as new messages are sent. Used during the challenge period for optimistic rollup security
	SendRoot []byte `protobuf:"bytes,27,opt,name=sendRoot,proto3,oneof" json:"sendRoot,omitempty"`
	// Minimum fee per gas unit (in wei) required for transaction inclusion in this block. Introduced in EIP-1559 (London fork). Algorithmically determined based on parent block's gas usage - increases when blocks are full, decreases when empty. Burned rather than paid to miners. Not applicable to pre-EIP-1559 chains or some L2s with different fee models
	BaseFeePerGas *string `protobuf:"bytes,28,opt,name=baseFeePerGas,proto3,oneof" json:"baseFeePerGas,omitempty"`
	// [DEPRECATED: Deprecated after Ethereum's transition to Proof-of-Stake (The Merge) in September 2022] PoW mining difficulty - how hard it was to find a valid nonce for this block. Adjusted every block to maintain target block time. Post-merge Ethereum sets this to 0. Still relevant for PoW chains (Ethereum Classic, some testnets). Replaced by randao in PoS
	Difficulty *string `protobuf:"bytes,29,opt,name=difficulty,proto3,oneof" json:"difficulty,omitempty"`
	// [DEPRECATED: Deprecated after Ethereum's transition to Proof-of-Stake (The Merge) in September 2022] Cumulative sum of all block difficulties from genesis to this block. Used to determine the canonical chain (highest total difficulty wins). Critical for PoW consensus and handling reorganizations. Post-merge this is frozen at the merge block's value. Only available from archive nodes as it requires historical computation
	TotalDifficulty *string `protobuf:"bytes,30,opt,name=totalDifficulty,proto3,oneof" json:"totalDifficulty,omitempty"`
	// BLS12-381 public key of the beacon chain validator that proposed this block. 48-byte hex-encoded key used in consensus layer cryptography. Enables attribution without querying validator registry. Used for distributed validator technology and staking pool analytics
	ProposerPublicKey *string `protobuf:"bytes,31,opt,name=proposerPublicKey,proto3,oneof" json:"proposerPublicKey,omitempty"`
	// Encoded withdrawal operations from beacon chain validators. Introduced in Shanghai upgrade. Contains validator index, withdrawal address, and amount. Usually RLP-encoded array. Empty for pre-Shanghai blocks. Envio stores as binary encoding
	Withdrawals []byte `protobuf:"bytes,32,opt,name=withdrawals,proto3,oneof" json:"withdrawals,omitempty"`
	// RLP (Recursive Length Prefix) encoded canonical block header. This is the exact bytes that when hashed produce the block hash. Used for block verification, light client proofs, and cross-chain bridges. Critical for trustless block validation
	CanonicalRlp []byte `protobuf:"bytes,33,opt,name=canonicalRlp,proto3,oneof" json:"canonicalRlp,omitempty"`
	// Array of uncle (ommer) block hashes included in this block. Uncle blocks are valid blocks mined at the same height but not included in the canonical chain. Ethereum rewarded up to 2 uncles per block to reduce mining centralization. Always empty post-merge. Some indexers store as JSON array
	Uncles        [][]byte `protobuf:"bytes,34,rep,name=uncles,proto3" json:"uncles,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BlockHeader) Reset() {
	*x = BlockHeader{}
	mi := &file_models_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BlockHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BlockHeader) ProtoMessage() {}

func (x *BlockHeader) ProtoReflect() protoreflect.Message {
	mi := &file_models_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BlockHeader.ProtoReflect.Descriptor instead.
func (*BlockHeader) Descriptor() ([]byte, []int) {
	return file_models_proto_rawDescGZIP(), []int{0}
}

func (x *BlockHeader) GetNumber() uint64 {
	if x != nil {
		return x.Number
	}
	return 0
}

func (x *BlockHeader) GetTimestamp() uint64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *BlockHeader) GetGasLimit() uint64 {
	if x != nil {
		return x.GasLimit
	}
	return 0
}

func (x *BlockHeader) GetGasUsed() uint64 {
	if x != nil {
		return x.GasUsed
	}
	return 0
}

func (x *BlockHeader) GetSize() uint64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *BlockHeader) GetHash() []byte {
	if x != nil {
		return x.Hash
	}
	return nil
}

func (x *BlockHeader) GetParentHash() []byte {
	if x != nil {
		return x.ParentHash
	}
	return nil
}

func (x *BlockHeader) GetStateRoot() []byte {
	if x != nil {
		return x.StateRoot
	}
	return nil
}

func (x *BlockHeader) GetTransactionsRoot() []byte {
	if x != nil {
		return x.TransactionsRoot
	}
	return nil
}

func (x *BlockHeader) GetReceiptsRoot() []byte {
	if x != nil {
		return x.ReceiptsRoot
	}
	return nil
}

func (x *BlockHeader) GetSha3Uncles() []byte {
	if x != nil {
		return x.Sha3Uncles
	}
	return nil
}

func (x *BlockHeader) GetMiner() []byte {
	if x != nil {
		return x.Miner
	}
	return nil
}

func (x *BlockHeader) GetLogsBloom() []byte {
	if x != nil {
		return x.LogsBloom
	}
	return nil
}

func (x *BlockHeader) GetExtraData() []byte {
	if x != nil {
		return x.ExtraData
	}
	return nil
}

func (x *BlockHeader) GetNonce() uint64 {
	if x != nil && x.Nonce != nil {
		return *x.Nonce
	}
	return 0
}

func (x *BlockHeader) GetBlobGasUsed() uint64 {
	if x != nil && x.BlobGasUsed != nil {
		return *x.BlobGasUsed
	}
	return 0
}

func (x *BlockHeader) GetExcessBlobGas() uint64 {
	if x != nil && x.ExcessBlobGas != nil {
		return *x.ExcessBlobGas
	}
	return 0
}

func (x *BlockHeader) GetL1BlockNumber() uint64 {
	if x != nil && x.L1BlockNumber != nil {
		return *x.L1BlockNumber
	}
	return 0
}

func (x *BlockHeader) GetEpoch() uint64 {
	if x != nil && x.Epoch != nil {
		return *x.Epoch
	}
	return 0
}

func (x *BlockHeader) GetSlot() uint64 {
	if x != nil && x.Slot != nil {
		return *x.Slot
	}
	return 0
}

func (x *BlockHeader) GetProposerIndex() uint64 {
	if x != nil && x.ProposerIndex != nil {
		return *x.ProposerIndex
	}
	return 0
}

func (x *BlockHeader) GetSendCount() uint64 {
	if x != nil && x.SendCount != nil {
		return *x.SendCount
	}
	return 0
}

func (x *BlockHeader) GetTransactionCount() uint32 {
	if x != nil && x.TransactionCount != nil {
		return *x.TransactionCount
	}
	return 0
}

func (x *BlockHeader) GetMixHash() []byte {
	if x != nil {
		return x.MixHash
	}
	return nil
}

func (x *BlockHeader) GetParentBeaconBlockRoot() []byte {
	if x != nil {
		return x.ParentBeaconBlockRoot
	}
	return nil
}

func (x *BlockHeader) GetWithdrawalsRoot() []byte {
	if x != nil {
		return x.WithdrawalsRoot
	}
	return nil
}

func (x *BlockHeader) GetSendRoot() []byte {
	if x != nil {
		return x.SendRoot
	}
	return nil
}

func (x *BlockHeader) GetBaseFeePerGas() string {
	if x != nil && x.BaseFeePerGas != nil {
		return *x.BaseFeePerGas
	}
	return ""
}

func (x *BlockHeader) GetDifficulty() string {
	if x != nil && x.Difficulty != nil {
		return *x.Difficulty
	}
	return ""
}

func (x *BlockHeader) GetTotalDifficulty() string {
	if x != nil && x.TotalDifficulty != nil {
		return *x.TotalDifficulty
	}
	return ""
}

func (x *BlockHeader) GetProposerPublicKey() string {
	if x != nil && x.ProposerPublicKey != nil {
		return *x.ProposerPublicKey
	}
	return ""
}

func (x *BlockHeader) GetWithdrawals() []byte {
	if x != nil {
		return x.Withdrawals
	}
	return nil
}

func (x *BlockHeader) GetCanonicalRlp() []byte {
	if x != nil {
		return x.CanonicalRlp
	}
	return nil
}

func (x *BlockHeader) GetUncles() [][]byte {
	if x != nil {
		return x.Uncles
	}
	return nil
}

// An event emitted by a smart contract during transaction execution on an EVM-compatible blockchain. Logs are the primary mechanism for smart contracts to communicate with external applications, enabling event-driven architectures and efficient querying of on-chain activity
type Log struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The 20-byte address of the smart contract that emitted this log. This is the contract whose code contained the LOG opcode (LOG0-LOG4) that generated this event. Used to filter logs by source contract and is included in the logs bloom filter for efficient block-level filtering
	Address []byte `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Array of indexed event parameters (max 4 topics). Topic[0] is the keccak256 hash of the event signature (e.g., 'Transfer(address,address,uint256)'). Topics[1-3] contain indexed event parameters. Indexed parameters enable efficient filtering but are limited to 32 bytes each. Dynamic types (strings, arrays) are hashed when indexed
	Topics [][]byte `protobuf:"bytes,2,rep,name=topics,proto3" json:"topics,omitempty"`
	// The non-indexed data of the log containing event parameters that are not indexed. While indexed parameters (topics) are limited to 32 bytes and enable filtering, non-indexed data can contain arbitrary length data including dynamic types. ABI-encoded according to the event definition in the contract ABI
	Data []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	// The block number where this log was emitted. Used for querying logs within block ranges, calculating confirmations, and determining the chronological order of events. Essential for applications that need to track state changes over time or react to events with specific finality requirements
	BlockNumber uint64 `protobuf:"varint,4,opt,name=blockNumber,proto3" json:"blockNumber,omitempty"`
	// The hash of the block containing this log. Provides a direct link to the block and enables verification that the log hasn't been altered. Can be null for pending logs. Used in conjunction with logIndex to uniquely identify a log and detect reorganizations when the hash changes
	BlockHash []byte `protobuf:"bytes,5,opt,name=blockHash,proto3" json:"blockHash,omitempty"`
	// The hash of the transaction that emitted this log. Links the log to its originating transaction, enabling retrieval of transaction details like sender, input data, and gas used. Multiple logs can share the same transaction hash if emitted by the same transaction
	TransactionHash []byte `protobuf:"bytes,6,opt,name=transactionHash,proto3" json:"transactionHash,omitempty"`
	// The zero-based index position of the transaction within its block. Combined with blockNumber/blockHash, this uniquely identifies the transaction. Used for maintaining order and understanding transaction execution sequence. Earlier transactions have lower indices
	TransactionIndex uint32 `protobuf:"varint,7,opt,name=transactionIndex,proto3" json:"transactionIndex,omitempty"`
	// The zero-based index position of this log within the block. Unique within a block and assigned sequentially as logs are emitted during transaction execution. Combined with blockHash, this provides a unique identifier for the log. Used for pagination and maintaining log order
	LogIndex uint32 `protobuf:"varint,8,opt,name=logIndex,proto3" json:"logIndex,omitempty"`
	// Unix timestamp of the block containing this log. Denormalized from block data for query convenience. Enables time-based filtering and analysis without joining block data. Same timestamp for all logs in a block
	BlockTimestamp *uint64 `protobuf:"varint,11,opt,name=blockTimestamp,proto3,oneof" json:"blockTimestamp,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *Log) Reset() {
	*x = Log{}
	mi := &file_models_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Log) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Log) ProtoMessage() {}

func (x *Log) ProtoReflect() protoreflect.Message {
	mi := &file_models_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Log.ProtoReflect.Descriptor instead.
func (*Log) Descriptor() ([]byte, []int) {
	return file_models_proto_rawDescGZIP(), []int{1}
}

func (x *Log) GetAddress() []byte {
	if x != nil {
		return x.Address
	}
	return nil
}

func (x *Log) GetTopics() [][]byte {
	if x != nil {
		return x.Topics
	}
	return nil
}

func (x *Log) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *Log) GetBlockNumber() uint64 {
	if x != nil {
		return x.BlockNumber
	}
	return 0
}

func (x *Log) GetBlockHash() []byte {
	if x != nil {
		return x.BlockHash
	}
	return nil
}

func (x *Log) GetTransactionHash() []byte {
	if x != nil {
		return x.TransactionHash
	}
	return nil
}

func (x *Log) GetTransactionIndex() uint32 {
	if x != nil {
		return x.TransactionIndex
	}
	return 0
}

func (x *Log) GetLogIndex() uint32 {
	if x != nil {
		return x.LogIndex
	}
	return 0
}

func (x *Log) GetBlockTimestamp() uint64 {
	if x != nil && x.BlockTimestamp != nil {
		return *x.BlockTimestamp
	}
	return 0
}

// Block with its transactions
type BlockWithTransactions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The block header
	Block *BlockHeader `protobuf:"bytes,1,opt,name=block,proto3" json:"block,omitempty"`
	// Transaction data (format depends on includeTransactions flag in request)
	Transactions  [][]byte `protobuf:"bytes,2,rep,name=transactions,proto3" json:"transactions,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BlockWithTransactions) Reset() {
	*x = BlockWithTransactions{}
	mi := &file_models_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BlockWithTransactions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BlockWithTransactions) ProtoMessage() {}

func (x *BlockWithTransactions) ProtoReflect() protoreflect.Message {
	mi := &file_models_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BlockWithTransactions.ProtoReflect.Descriptor instead.
func (*BlockWithTransactions) Descriptor() ([]byte, []int) {
	return file_models_proto_rawDescGZIP(), []int{2}
}

func (x *BlockWithTransactions) GetBlock() *BlockHeader {
	if x != nil {
		return x.Block
	}
	return nil
}

func (x *BlockWithTransactions) GetTransactions() [][]byte {
	if x != nil {
		return x.Transactions
	}
	return nil
}

var File_models_proto protoreflect.FileDescriptor

const file_models_proto_rawDesc = "" +
	"\n" +
	"\fmodels.proto\x12\abds.evm\"\xe9\v\n" +
	"\vBlockHeader\x12\x16\n" +
	"\x06number\x18\x01 \x01(\x04R\x06number\x12\x1c\n" +
	"\ttimestamp\x18\x02 \x01(\x04R\ttimestamp\x12\x1a\n" +
	"\bgasLimit\x18\x03 \x01(\x04R\bgasLimit\x12\x18\n" +
	"\agasUsed\x18\x04 \x01(\x04R\agasUsed\x12\x12\n" +
	"\x04size\x18\x05 \x01(\x04R\x04size\x12\x12\n" +
	"\x04hash\x18\x06 \x01(\fR\x04hash\x12\x1e\n" +
	"\n" +
	"parentHash\x18\a \x01(\fR\n" +
	"parentHash\x12\x1c\n" +
	"\tstateRoot\x18\b \x01(\fR\tstateRoot\x12*\n" +
	"\x10transactionsRoot\x18\t \x01(\fR\x10transactionsRoot\x12\"\n" +
	"\freceiptsRoot\x18\n" +
	" \x01(\fR\freceiptsRoot\x12\x1e\n" +
	"\n" +
	"sha3Uncles\x18\v \x01(\fR\n" +
	"sha3Uncles\x12\x14\n" +
	"\x05miner\x18\f \x01(\fR\x05miner\x12\x1c\n" +
	"\tlogsBloom\x18\r \x01(\fR\tlogsBloom\x12\x1c\n" +
	"\textraData\x18\x0e \x01(\fR\textraData\x12\x19\n" +
	"\x05nonce\x18\x0f \x01(\x04H\x00R\x05nonce\x88\x01\x01\x12%\n" +
	"\vblobGasUsed\x18\x10 \x01(\x04H\x01R\vblobGasUsed\x88\x01\x01\x12)\n" +
	"\rexcessBlobGas\x18\x11 \x01(\x04H\x02R\rexcessBlobGas\x88\x01\x01\x12)\n" +
	"\rl1BlockNumber\x18\x12 \x01(\x04H\x03R\rl1BlockNumber\x88\x01\x01\x12\x19\n" +
	"\x05epoch\x18\x13 \x01(\x04H\x04R\x05epoch\x88\x01\x01\x12\x17\n" +
	"\x04slot\x18\x14 \x01(\x04H\x05R\x04slot\x88\x01\x01\x12)\n" +
	"\rproposerIndex\x18\x15 \x01(\x04H\x06R\rproposerIndex\x88\x01\x01\x12!\n" +
	"\tsendCount\x18\x16 \x01(\x04H\aR\tsendCount\x88\x01\x01\x12/\n" +
	"\x10transactionCount\x18\x17 \x01(\rH\bR\x10transactionCount\x88\x01\x01\x12\x1d\n" +
	"\amixHash\x18\x18 \x01(\fH\tR\amixHash\x88\x01\x01\x129\n" +
	"\x15parentBeaconBlockRoot\x18\x19 \x01(\fH\n" +
	"R\x15parentBeaconBlockRoot\x88\x01\x01\x12-\n" +
	"\x0fwithdrawalsRoot\x18\x1a \x01(\fH\vR\x0fwithdrawalsRoot\x88\x01\x01\x12\x1f\n" +
	"\bsendRoot\x18\x1b \x01(\fH\fR\bsendRoot\x88\x01\x01\x12)\n" +
	"\rbaseFeePerGas\x18\x1c \x01(\tH\rR\rbaseFeePerGas\x88\x01\x01\x12#\n" +
	"\n" +
	"difficulty\x18\x1d \x01(\tH\x0eR\n" +
	"difficulty\x88\x01\x01\x12-\n" +
	"\x0ftotalDifficulty\x18\x1e \x01(\tH\x0fR\x0ftotalDifficulty\x88\x01\x01\x121\n" +
	"\x11proposerPublicKey\x18\x1f \x01(\tH\x10R\x11proposerPublicKey\x88\x01\x01\x12%\n" +
	"\vwithdrawals\x18  \x01(\fH\x11R\vwithdrawals\x88\x01\x01\x12'\n" +
	"\fcanonicalRlp\x18! \x01(\fH\x12R\fcanonicalRlp\x88\x01\x01\x12\x16\n" +
	"\x06uncles\x18\" \x03(\fR\x06unclesB\b\n" +
	"\x06_nonceB\x0e\n" +
	"\f_blobGasUsedB\x10\n" +
	"\x0e_excessBlobGasB\x10\n" +
	"\x0e_l1BlockNumberB\b\n" +
	"\x06_epochB\a\n" +
	"\x05_slotB\x10\n" +
	"\x0e_proposerIndexB\f\n" +
	"\n" +
	"_sendCountB\x13\n" +
	"\x11_transactionCountB\n" +
	"\n" +
	"\b_mixHashB\x18\n" +
	"\x16_parentBeaconBlockRootB\x12\n" +
	"\x10_withdrawalsRootB\v\n" +
	"\t_sendRootB\x10\n" +
	"\x0e_baseFeePerGasB\r\n" +
	"\v_difficultyB\x12\n" +
	"\x10_totalDifficultyB\x14\n" +
	"\x12_proposerPublicKeyB\x0e\n" +
	"\f_withdrawalsB\x0f\n" +
	"\r_canonicalRlp\"\xbd\x02\n" +
	"\x03Log\x12\x18\n" +
	"\aaddress\x18\x01 \x01(\fR\aaddress\x12\x16\n" +
	"\x06topics\x18\x02 \x03(\fR\x06topics\x12\x12\n" +
	"\x04data\x18\x03 \x01(\fR\x04data\x12 \n" +
	"\vblockNumber\x18\x04 \x01(\x04R\vblockNumber\x12\x1c\n" +
	"\tblockHash\x18\x05 \x01(\fR\tblockHash\x12(\n" +
	"\x0ftransactionHash\x18\x06 \x01(\fR\x0ftransactionHash\x12*\n" +
	"\x10transactionIndex\x18\a \x01(\rR\x10transactionIndex\x12\x1a\n" +
	"\blogIndex\x18\b \x01(\rR\blogIndex\x12+\n" +
	"\x0eblockTimestamp\x18\v \x01(\x04H\x00R\x0eblockTimestamp\x88\x01\x01B\x11\n" +
	"\x0f_blockTimestamp\"g\n" +
	"\x15BlockWithTransactions\x12*\n" +
	"\x05block\x18\x01 \x01(\v2\x14.bds.evm.BlockHeaderR\x05block\x12\"\n" +
	"\ftransactions\x18\x02 \x03(\fR\ftransactionsB4Z2github.com/blockchain-data-standards/manifesto/evmb\x06proto3"

var (
	file_models_proto_rawDescOnce sync.Once
	file_models_proto_rawDescData []byte
)

func file_models_proto_rawDescGZIP() []byte {
	file_models_proto_rawDescOnce.Do(func() {
		file_models_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_models_proto_rawDesc), len(file_models_proto_rawDesc)))
	})
	return file_models_proto_rawDescData
}

var file_models_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_models_proto_goTypes = []any{
	(*BlockHeader)(nil),           // 0: bds.evm.BlockHeader
	(*Log)(nil),                   // 1: bds.evm.Log
	(*BlockWithTransactions)(nil), // 2: bds.evm.BlockWithTransactions
}
var file_models_proto_depIdxs = []int32{
	0, // 0: bds.evm.BlockWithTransactions.block:type_name -> bds.evm.BlockHeader
	1, // [1:1] is the sub-list for method output_type
	1, // [1:1] is the sub-list for method input_type
	1, // [1:1] is the sub-list for extension type_name
	1, // [1:1] is the sub-list for extension extendee
	0, // [0:1] is the sub-list for field type_name
}

func init() { file_models_proto_init() }
func file_models_proto_init() {
	if File_models_proto != nil {
		return
	}
	file_models_proto_msgTypes[0].OneofWrappers = []any{}
	file_models_proto_msgTypes[1].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_models_proto_rawDesc), len(file_models_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   3,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_models_proto_goTypes,
		DependencyIndexes: file_models_proto_depIdxs,
		MessageInfos:      file_models_proto_msgTypes,
	}.Build()
	File_models_proto = out.File
	file_models_proto_goTypes = nil
	file_models_proto_depIdxs = nil
}
